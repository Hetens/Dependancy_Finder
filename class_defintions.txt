// Go does not support traditional inheritance but uses composition
type Animal struct {
    Name string
}

type Dog struct {
    Animal
    Breed string
}
trait Animal {
    fn make_sound(&self);
}

struct Dog;

impl Animal for Dog {
    fn make_sound(&self) {
        println!("Woof!");
    }
}
class Vehicle:
    def __init__(self, make, model):
        self.make = make
        self.model = model

class Car(Vehicle):
    def __init__(self, make, model, doors):
        super().__init__(make, model)
        self.doors = doors
class Animal {
    constructor(name) {
        this.name = name;
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name);
        this.breed = breed;
    }
}
class Animal {
    name: string;

    constructor(name: string) {
        this.name = name;
    }
}

class Dog extends Animal {
    breed: string;

    constructor(name: string, breed: string) {
        super(name);
        this.breed = breed;
    }
}
typedef struct {
    char make[50];
    char model[50];
} Vehicle;

typedef struct {
    Vehicle vehicle;
    int doors;
} Car;
class Animal {
public:
    std::string name;
    Animal(std::string n) : name(n) {}
};

class Dog : public Animal {
public:
    std::string breed;
    Dog(std::string n, std::string b) : Animal(n), breed(b) {}
};
class Animal {
    private String name;

    public Animal(String name) {
        this.name = name;
    }
}

class Dog extends Animal {
    private String breed;

    public Dog(String name, String breed) {
        super(name);
        this.breed = breed;
    }
}
class Animal {
    var name: String

    init(name: String) {
        self.name = name
    }
}

class Dog: Animal {
    var breed: String

    init(name: String, breed: String) {
        self.breed = breed
        super.init(name: name)
    }
}
open class Animal(val name: String)

class Dog(name: String, val breed: String) : Animal(name)
class Animal
    def initialize(name)
        @name = name
    end
end

class Dog < Animal
    def initialize(name, breed)
        super(name)
        @breed = breed
    end
end
class Animal {
    private $name;

    public function __construct($name) {
        $this->name = $name;
    }
}

class Dog extends Animal {
    private $breed;

    public function __construct($name, $breed) {
        parent::__construct($name);
        $this->breed = $breed;
    }
}
package Animal;

sub new {
    my ($class, $name) = @_;
    my $self = {
        name => $name
    };
    bless $self, $class;
    return $self;
}

package Dog;
use base 'Animal';

sub new {
    my ($class, $name, $breed) = @_;
    my $self = $class->SUPER::new($name);
    $self->{breed} = $breed;
    bless $self, $class;
    return $self;
}
